/**
* modelify.js
*
* Generates beautiful ES6-based Parse models for use in our app. It even does
* validations! You still have to add some custom things though... but it's a
* nice start.
*
* Hand crafted with <3 by Trevor.
*/

'use strict';

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var klass = process.argv[2];
var attrs = _lodash2.default.drop(process.argv, 3);

// Start off our model with some nice code.
// NOTE: Don't use this for User model right now! User model (and other built-in
// Parse classes) are set up slightly differently and aren't supported yet.
var model = '/**\n* ' + klass + ' model\n*\n* Autogenerated by modelify.js.\n* TODO: Add your own documentation for this file here.\n*/\n\n\'use strict\';\n\nexport default function (app) {\n\tconst PARSE_CLASSNAME = \'' + klass + '\';\n\n\tconst Parse = app.Parse;\n\tconst _ = app._;\n\tconst validate = app.validate;\n\n\tclass ' + klass + ' extends Parse.Object {\n\t\tconstructor(o) {\n\t\t\tsuper(PARSE_CLASSNAME);\n\n\t\t\to = validate(o, _.isObject);\n';

// This will be an array containing code to add to model that sets the attributes
// in the Parse database.
var sets = [];

// Parse each attribute. Type (i.e. what we will validate the attribute with) comes after a colon,
// like so: name:type(!). Optional ! at the end of type forces the attribute to be non-empty and
// non-null before it can be validated.
// TODO: For non-typed attributes (aka user might add custom validation methods), allow ! to be
// appended directly to the name. Example, 'modelify Update title! subtitle!'
_lodash2.default.each(attrs, function (attr) {
	attr = attr.split(':');
	var name = attr[0];
	var type = attr[1];
	var force = false; // Default

	if (_lodash2.default.endsWith(name, '!')) {
		force = true;
		name = _lodash2.default.trimRight(name, '!');
	} else if (_lodash2.default.endsWith(type, '!')) {
		force = true;
		type = _lodash2.default.trimRight(type, '!');
	}

	// NOTE: The formatting of these template strings may make your eyes bleed, but it
	// helps with spacing in the generated file!
	// First, the easy part. Generate the this.set methods for each attribute.
	var set = '\t\t\tthis.set(\'' + name + '\', this.' + name + ');\n';
	sets.push(set);

	// Generate a validation for each attribute.
	// Options are:
	//     (1) No type (custom validation method) AND forced (non-falsey).
	//     (2) No type AND not forced
	//     (3) Typed (lodash function) AND forced
	//     (4) Typed AND not forced
	if (_lodash2.default.isEmpty(type)) {
		// Option 1
		if (force) {
			model += '\t\t\tthis.' + name + ' = validate(o.' + name + ', ' + name + ' => {\n\t\t\t\treturn !!' + name + ';\n\t\t\t});\n';
		}
		// Option 2
		else {
				model += '\t\t\tthis.' + name + ' = validate(o.' + name + ', ' + name + ' => {\n\t\t\t\treturn;\n\t\t\t});\n';
			}
	} else {
		// Option 3
		if (force) {
			model += '\t\t\tthis.' + name + ' = validate(o.' + name + ', ' + name + ' => {\n\t\t\t\treturn !!' + name + ' && _.is' + type + '(' + name + ');\n\t\t\t});\n';
		}
		// Option 4
		else {
				model += '\t\t\tthis.' + name + ' = validate(o.' + name + ', _.is' + type + ');\n';
			}
	}
});

// Insert a newline for spacing, and add this.set methods for each attribute.
model += '\n';
_lodash2.default.each(sets, function (set) {
	return model += set;
});

// Finish up our model
model += '\t\t}\n\t}\n\n\tapp.model.' + klass + ' = ' + klass + ';\n\tParse.Object.registerSubclass(PARSE_CLASSNAME, ' + klass + ');\n}\n';

// Write our beautiful new model file!
_fs2.default.writeFile('app/models/' + klass + '.js', model, function (err) {
	if (err) {
		throw err;
	}

	console.log('Model ' + klass + ' created as app/models/' + klass + '.js\n');
});
//# sourceMappingURL=modelify.js.map
