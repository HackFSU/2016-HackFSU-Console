{"version":3,"sources":["modelify.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAiBA,YAAY,CAAC;;;;;;;;;;;;AAKb,IAAI,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC5B,IAAI,KAAK,GAAG,iBAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;;;;AAAC,AAIpC,IAAI,WAAW,GAAG,QAAQ,CAAC;AAC3B,IAAI,KAAK,KAAK,MAAM,EAAE;AACrB,YAAW,GAAG,MAAM,CAAC;CACrB;;;AAAA,AAGD,IAAI,KAAK,eAEL,KAAK,kMASmB,KAAK,2GAMxB,KAAK,uBAAkB,WAAW,oGAK1C;;;;AAAC,AAIF,IAAI,IAAI,GAAG,EAAE;;;;;;;AAAC,AAOd,iBAAE,IAAI,CAAC,KAAK,EAAE,UAAA,IAAI,EAAI;AACrB,KAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACvB,KAAI,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AACnB,KAAI,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AACnB,KAAI,KAAK,GAAG,KAAK;;AAAC,AAElB,KAAI,iBAAE,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;AAC1B,OAAK,GAAG,IAAI,CAAC;AACb,MAAI,GAAG,iBAAE,SAAS,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;EAC9B,MACI,IAAI,iBAAE,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;AAC/B,OAAK,GAAG,IAAI,CAAC;AACb,MAAI,GAAG,iBAAE,SAAS,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;EAC9B;;;;;AAAA,AAKD,KAAI,GAAG,yBACQ,IAAI,iBAAW,IAAI,SAClC,CAAC;AACD,KAAI,CAAC,IAAI,CAAC,GAAG,CAAC;;;;;;;;AAAC,AAQf,KAAI,iBAAE,OAAO,CAAC,IAAI,CAAC,EAAE;;AAEpB,MAAI,KAAK,EAAE;AACV,QAAK,oBACG,IAAI,sBAAiB,IAAI,UAAK,IAAI,gCAC9B,IAAI,mBAElB,CAAC;;;AACC,OAEI;AACJ,SAAK,oBACG,IAAI,sBAAiB,IAAI,UAAK,IAAI,wCAG5C,CAAC;IACA;EACA,MACI;;AAEJ,MAAI,KAAK,EAAE;AACV,QAAK,oBACG,IAAI,sBAAiB,IAAI,UAAK,IAAI,gCAC9B,IAAI,gBAAW,IAAI,SAAI,IAAI,oBAEzC,CAAC;;;AACC,OAEI;AACJ,SAAK,oBACG,IAAI,sBAAiB,IAAI,cAAS,IAAI,SAChD,CAAC;IACC;EACD;CACD,CAAC;;;AAAC,AAGH,KAAK,IAAI,IAAI,CAAC;AACd,iBAAE,IAAI,CAAC,IAAI,EAAE,UAAA,GAAG;QAAI,KAAK,IAAI,GAAG;CAAA,CAAC;;;AAAC,AAGlC,KAAK,mCAIQ,KAAK,WAAM,KAAK,4DACqB,KAAK,YAEtD;;;AAAC,AAGF,aAAG,SAAS,iBAAe,KAAK,UAAO,KAAK,EAAE,UAAU,GAAG,EAAE;AAC3D,KAAI,GAAG,EAAE;AACR,QAAM,GAAG,CAAC;EACV;;AAED,QAAO,CAAC,GAAG,YAAU,KAAK,+BAA0B,KAAK,WAAQ,CAAC;CACnE,CAAC,CAAC","file":"modelify.js","sourcesContent":["/**\n* modelify.js\n*\n* Generates beautiful ES6-based Parse models for use in our app. It even does\n* validations! You still have to add some custom things though... but it's a\n* nice start.\n*\n* Hand crafted with <3 by Trevor.\n*\n* TODO: I think it would be bad ass if these could be set up in such a way as to\n* allow us to create a schema.js file that we can load instead of generating them\n* from the command line. That way, we have a common place to view the database schema,\n* we can write custom validators and implement them into the generated model code,\n* and any time a model is generated from the command line, we can add it/update it\n* in the schema.js file.\n*/\n\n'use strict';\n\nimport _ from 'lodash';\nimport fs from 'fs';\n\nlet klass = process.argv[2];\nlet attrs = _.drop(process.argv, 3);\n\n// Default class extension to Parse.Object, but some built-in objects need to be\n// specifically subclassed\nlet parseObject = 'Object';\nif (klass === 'User') {\n\tparseObject = 'User';\n}\n\n// Start off our model with some nice code.\nlet model =\n`/**\n* ${klass} model\n*\n* Autogenerated by modelify.js.\n* TODO: Add your own documentation for this file here.\n*/\n\n'use strict';\n\nexport default function (app) {\n\tconst PARSE_CLASSNAME = '${klass}';\n\n\tconst Parse = app.Parse;\n\tconst _ = app._;\n\tconst validate = app.validate;\n\n\tclass ${klass} extends Parse.${parseObject} {\n\t\tconstructor(o) {\n\t\t\tsuper(PARSE_CLASSNAME);\n\n\t\t\to = validate(o, _.isObject);\n`;\n\n// This will be an array containing code to add to model that sets the attributes\n// in the Parse database.\nlet sets = [];\n\n// Parse each attribute. Type (i.e. what we will validate the attribute with) comes after a colon,\n// like so: name:type(!). Optional ! at the end of type forces the attribute to be non-empty and\n// non-null before it can be validated.\n// TODO: For non-typed attributes (aka user might add custom validation methods), allow ! to be\n// appended directly to the name. Example, 'modelify Update title! subtitle!'\n_.each(attrs, attr => {\n\tattr = attr.split(':');\n\tlet name = attr[0];\n\tlet type = attr[1];\n\tlet force = false; \t\t// Default\n\n\tif (_.endsWith(name, '!')) {\n\t\tforce = true;\n\t\tname = _.trimRight(name, '!');\n\t}\n\telse if (_.endsWith(type, '!')) {\n\t\tforce = true;\n\t\ttype = _.trimRight(type, '!');\n\t}\n\n\t// NOTE: The formatting of these template strings may make your eyes bleed, but it\n\t// helps with spacing in the generated file!\n\t// First, the easy part. Generate the this.set methods for each attribute.\n\tlet set =\n`\t\t\tthis.set('${name}', this.${name});\n`;\n\tsets.push(set);\n\n\t// Generate a validation for each attribute.\n\t// Options are:\n\t//     (1) No type (custom validation method) AND forced (non-falsey).\n\t//     (2) No type AND not forced\n\t//     (3) Typed (lodash function) AND forced\n\t//     (4) Typed AND not forced\n\tif (_.isEmpty(type)) {\n\t\t// Option 1\n\t\tif (force) {\n\t\t\tmodel +=\n`\t\t\tthis.${name} = validate(o.${name}, ${name} => {\n\t\t\t\treturn !!${name};\n\t\t\t});\n`;\n\t\t}\n\t\t// Option 2\n\t\telse {\n\t\t\tmodel +=\n`\t\t\tthis.${name} = validate(o.${name}, ${name} => {\n\t\t\t\treturn;\n\t\t\t});\n`;\n\t}\n\t}\n\telse {\n\t\t// Option 3\n\t\tif (force) {\n\t\t\tmodel +=\n`\t\t\tthis.${name} = validate(o.${name}, ${name} => {\n\t\t\t\treturn !!${name} && _.is${type}(${name});\n\t\t\t});\n`;\n\t\t}\n\t\t// Option 4\n\t\telse {\n\t\t\tmodel +=\n`\t\t\tthis.${name} = validate(o.${name}, _.is${type});\n`;\n\t\t}\n\t}\n});\n\n// Insert a newline for spacing, and add this.set methods for each attribute.\nmodel += '\\n';\n_.each(sets, set => model += set);\n\n// Finish up our model\nmodel +=\n`\t\t}\n\t}\n\n\tapp.model.${klass} = ${klass};\n\tParse.Object.registerSubclass(PARSE_CLASSNAME, ${klass});\n}\n`;\n\n// Write our beautiful new model file!\nfs.writeFile(`app/models/${klass}.js`, model, function (err) {\n  if (err) {\n\t  throw err;\n  }\n\n  console.log(`Model ${klass} created as app/models/${klass}.js\\n`);\n});\n"],"sourceRoot":"/src"}