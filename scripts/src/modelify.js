/**
* Generates beautiful ES6-based Parse models for use in our app. It even does
* validations! You still have to add some custom things though... but it's a
* nice start.
*
* Hand crafted with love by Trevor.
*/

'use strict';

import _ from 'lodash';
import fs from 'fs';

let klass = process.argv[2];
let attrs = _.drop(process.argv, 3);

// Start off our model with some nice code.
let model = `
/**
* ${klass} model
*
* Autogenerated by modelify.js.
* TODO: Add your own documentation for this file here.
*/

export default function (app) {
	const PARSE_CLASSNAME = '${klass}';

	const Parse = app.Parse;
	const _ = app._;
	const validate = app.validate;

	class ${klass} extends Parse.Object {
		constructor(o) {
			super(PARSE_CLASSNAME);

			o = validate(o, _.isObject);
`;

// Parse each attribute. Type (i.e. what we will validate the attribute with) comes after a colon,
// like so: name:type(!). Optional ! at the end of type forces the attribute to be non-empty and
// non-null before it can be validated.
// TODO: For non-typed attributes (aka user might add custom validation methods), allow ! to be
// appended directly to the name. Example, 'modelify Update title! subtitle!'
_.each(attrs, function(attr) {
	attr = attr.split(':');
	let name = attr[0];
	let type = attr[1];
	let force = type[type.length - 1];

	// For now, this only supports lodash methods and calls _.is{Type} function.
	// TODO: Support custom entries.
	// TODO: Support force.
	model += `\t\t\tthis.${name} = validate(o.${name}, _.is${type});\n`;		// TODO: Uppercase first letter to support lowercase types in the cmd line?
});

// Finish up our model
model += `
		}
	}

	app.model.${klass} = ${klass};
	Parse.Object.registerSubclass(PARSE_CLASSNAME, ${klass});
}
`;

// Write our beautiful new model file!
fs.writeFile(`app/models/${klass}.js`, model, function (err) {
  if (err) {
	  throw err;
  }

  console.log(`Model ${klass} created as app/models/${klass}.js\n`);
});
