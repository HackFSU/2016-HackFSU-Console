// Generated by CoffeeScript 1.8.0

/* 
	Parse Cloud code for HackFSU-test
	
	To update, follow this: https://www.parse.com/docs/cloud_code_guide#started
	Must be manually converted into .js
	global.json is required (gitignored, see Jared)

EXAMPLE:

Parse.Cloud.define "hello", (req, res)->
  res.success "Hello world!"
 */
Parse.Cloud.define("getAllConfirmationIds", function(req, res) {
  var query;
  Parse.Cloud.useMasterKey();
  query = new Parse.Query('Applications');
  query.limit(1000);
  query.find({
    success: function(results) {
      var app, ids, _i, _len;
      ids = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        app = results[_i];
        if ((app.get('confirmationId')) != null) {
          ids.push(app.get('confirmationId'));
        }
      }
      res.success(ids);
    },
    error: function(error) {
      res.error(error);
    }
  });
});


/*
	Checks if a confirmation id is valid.
	if it is, result = 
		valid: true
		objectId: (string)
		firstName: (string)
		lastName: (string)
		hasDiet: (boolean)		#if we have data on their diet question
		status: (string)
	if it isnt, result =
		valid: false
 */

Parse.Cloud.define("getAppSimpleByConfirmationId", function(req, res) {
  var query;
  Parse.Cloud.useMasterKey();
  query = new Parse.Query('Applications');
  query.equalTo('confirmationId', req.params.confirmationId);
  query.limit(1);
  query.find({
    success: function(results) {
      if (results.length === 0) {
        res.success({
          valid: false
        });
      } else {
        res.success({
          valid: true,
          objectId: results[0].get('objectId'),
          firstName: results[0].get('firstName'),
          lastName: results[0].get('lastName'),
          hasDiet: (results[0].get('QAs'))[3].trim() != null,
          status: results[0].get('status')
        });
      }
    },
    error: function(error) {
      res.error(error);
    }
  });
});


/*
	Grabs just enough data from the app with the objectId to send an email
	if valid, result = 
		firstName: (string)
		lastName: (string)
		email: (string)
	else result = null
 */

Parse.Cloud.define("getAppSimpleByObjectId", function(req, res) {
  var query;
  Parse.Cloud.useMasterKey();
  query = new Parse.Query('Applications');
  query.equalTo('objectId', req.params.objectId);
  query.limit(1);
  query.find({
    success: function(results) {
      if (results.length === 0) {
        res.success(null);
      } else {
        res.success({
          firstName: results[0].get('firstName'),
          lastName: results[0].get('lastName'),
          email: results[0].get('email'),
          status: results[0].get('status')
        });
      }
    },
    error: function(error) {
      res.error(error);
    }
  });
});


/*
	Creates multiple AnonStats objects in one call
	data =
		birthdate: string
		gender: string
 */

Parse.Cloud.define('createAnonStats', function(req, res) {
  var errorMsg, msg, saveStat;
  Parse.Cloud.useMasterKey();
  msg = '';
  errorMsg = '';
  saveStat = function(statName, statValue) {
    var AnonStats, as, prom;
    prom = new Parse.Promise();
    if (statValue != null) {
      AnonStats = Parse.Object.extend('AnonStats');
      as = new AnonStats();
      as.set('statName', statName);
      as.set('statValue', statValue);
      as.save(null, {
        success: function(aStat) {
          msg += 'added ' + statName + ';';
          prom.resolve();
        },
        error: function(error) {
          errorMsg += 'ERROR CREATING ' + statName + ';';
          prom.resolve();
        }
      });
    } else {
      prom.resolve();
    }
    return prom;
  };
  saveStat('birthdate', req.params.birthdate).then(function() {
    return saveStat('gender', req.params.gender).then(function() {
      if (errorMsg) {
        return res.error(errorMsg);
      } else {
        return res.success(msg);
      }
    });
  });
});


/*
	Sets all application statuses to 'pending'
 */

Parse.Cloud.define('resetApplications', function(req, res) {
  var query;
  Parse.Cloud.useMasterKey();
  query = new Parse.Query('Applications');
  query.limit(1000);
  query.find({
    success: function(results) {
      var app, _i, _len;
      if (results.length === 0) {
        res.success(0);
      } else {
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          app = results[_i];
          app.set('status', 'pending');
        }
        Parse.Object.saveAll(results).then(function(objs) {
          return res.success('Complete.');
        }, function(err) {
          return res.error('Error.');
        });
      }
    },
    error: function(error) {
      res.error(error);
    }
  });
});


/*
	Returns counts of each app status type
 */

Parse.Cloud.define('getAppStatusCounts', function(req, res) {
  var query;
  Parse.Cloud.useMasterKey();
  query = new Parse.Query('Applications');
  query.limit(1000);
  return query.find({
    success: function(results) {
      var app, counts, _i, _len;
      counts = {
        pending: 0,
        waitlisted: 0,
        accepted: 0,
        going: 0,
        notGoing: 0
      };
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        app = results[_i];
        switch (app.get('status')) {
          case 'pending':
            ++counts.pending;
            break;
          case 'waitlisted':
            ++counts.waitlisted;
            break;
          case 'accepted':
            ++counts.accepted;
            break;
          case 'going':
            ++counts.going;
            break;
          case 'not going':
            ++counts.notGoing;
        }
      }
      res.success(counts);
    },
    error: function(error) {
      res.error(error);
    }
  });
});
